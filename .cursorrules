# Token Toilet AI Code Generation Guidelines ðŸš½

## Project Context
This is a Web3 DeFi application built with Next.js 14, TypeScript, and Tailwind CSS that helps users dispose of unwanted tokens while contributing to charitable causes. The project follows modern React patterns and emphasizes type safety.

## Technical Stack Requirements
- Use Next.js 14 App Router architecture
- Write all code in TypeScript with strict type checking
- Style components using Tailwind CSS
- Implement Web3 functionality using ethers.js/viem
- Follow React Server Components patterns where applicable

## Coding Standards

### TypeScript & JavaScript
- Use TypeScript for all new files with strict type checking enabled
- Prefer `const` over `let` for variable declarations
- Use optional chaining and nullish coalescing operators
- Implement proper error handling with typed errors
- Use async/await for asynchronous operations
- Follow ESM import/export syntax

### React & Components
- Use functional components with hooks
- Implement proper error boundaries for Web3 interactions
- Follow the Container/Presenter pattern for complex components
- Use React Server Components by default, Client Components only when necessary
- Implement proper loading and error states for all async operations

### File Structure
- Place page components in `app/` directory
- Store reusable components in `components/`
- Keep Web3 related code in `lib/web3/`
- Maintain types in `types/` directory
- Store contract ABIs in `contracts/abis/`
- Keep utility functions in `utils/`

### Styling
- Use Tailwind CSS utility classes
- Follow mobile-first responsive design
- Maintain dark mode support
- Use CSS variables for theme colors
- Keep custom CSS in `*.module.css` files when needed

### Web3 Integration
- Implement proper wallet connection error handling
- Use typed contract interactions
- Follow EIP standards for token interactions
- Implement proper transaction state management
- Handle multiple chain support gracefully

### Testing
- Write unit tests using Jest and React Testing Library
- Include integration tests for Web3 functionality
- Test both light and dark mode scenarios
- Implement proper mock providers for Web3 tests
- Maintain high test coverage for critical paths

### Performance
- Implement proper code splitting
- Use proper caching strategies
- Optimize images and assets
- Minimize client-side JavaScript
- Follow React performance best practices

### Security
- Never expose private keys or sensitive data
- Implement proper input validation
- Follow Web3 security best practices
- Use environment variables for configuration
- Implement proper rate limiting

### Documentation
- Use JSDoc comments for functions and components
- Include prop type documentation
- Maintain README files in major directories
- Document Web3 integration points
- Keep inline comments focused and meaningful

## Formatting
- Use Prettier with project configuration
- Maximum line length of 120 characters
- Use single quotes for strings
- No semicolons
- 2 space indentation

## Dependencies
- Use pnpm for package management
- Keep dependencies up to date using Renovate
- Avoid unnecessary dependencies
- Use specific version numbers
- Document breaking changes

## Git Workflow
- Follow conventional commits
- Keep PRs focused and small
- Include tests with changes
- Update documentation as needed
- Maintain linear history

## Error Handling
- Use custom error types
- Implement proper error boundaries
- Log errors appropriately
- Provide user-friendly error messages
- Handle Web3 specific errors gracefully
